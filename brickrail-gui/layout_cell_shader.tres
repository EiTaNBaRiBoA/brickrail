[gd_resource type="ShaderMaterial" load_steps=2 format=2]

[sub_resource type="Shader" id=2]
code = "shader_type canvas_item;

uniform vec4 background: hint_color;
uniform vec4 track_base: hint_color;
uniform vec4 track_inner: hint_color;

uniform bool NS;
uniform bool NE;
uniform bool NW;
uniform bool SE;
uniform bool SW;
uniform bool EW;

uniform mat4 matrix;

uniform ivec3 connections_n: hint_vec4;
uniform ivec3 connections_e: hint_vec4;
uniform ivec3 connections_s: hint_vec4;
uniform ivec3 connections_w: hint_vec4;



float circle(vec2 position, float radius) {
    return length(position) - radius;
}

float rectangle(vec2 position, vec2 size) {
    vec2 component_distance = abs(position) - size;
    float outside_distance = length(max(component_distance, 0.0));
    float inside_distance = min(max(component_distance.x, component_distance.y), 0.0);
    return outside_distance + inside_distance;
	// return component_distance.x;
}

vec2 translate(vec2 position, vec2 offset) {
	return position - offset;
}

vec2 rotate(vec2 position, float rotation) {
    const float PI = 3.14159;
    float angle = rotation;
    float sine = sin(angle);
	float cosine = cos(angle);
    return vec2(cosine * position.x + sine * position.y, cosine * position.y - sine * position.x);
}

float merge(float shape1, float shape2) {
	return min(shape1, shape2);
}

float intersect(float shape1, float shape2) {
	return max(shape1, shape2);
}

float substract(float shape1, float shape2) {
	return intersect(shape1, -shape2);
}

float interpolate(float shape1, float shape2, float t) {
	return mix(shape1, shape2, t);
}


float line(vec2 position, vec2 from, vec2 to, float width) {
	vec2 delta = to-from;
	float angle = atan(delta.y, delta.x);
	vec2 rect_pos = position;
	rect_pos = translate(rect_pos, 0.5*(from+to));
	rect_pos = rotate(rect_pos, angle);
	float rect = rectangle(rect_pos,vec2(length(delta)*0.5, width));
	return rect;
}

float track_connection(vec2 position, int from_slot, int to_slot, int turn_index) {
	vec2 slot_positions[4] = {vec2(0.5, 0.0), vec2(1.0, 0.5), vec2(0.5, 1.0), vec2(0.0, 0.5)};
	return position.x;
}

float track_segment(vec2 position, int slot1, int slot2) {
	vec2 slot_positions[4] = {vec2(0.5, 0.0), vec2(1.0, 0.5), vec2(0.5, 1.0), vec2(0.0, 0.5)};
	vec2 pos1 = slot_positions[slot1];
	vec2 pos2 = slot_positions[slot2];
	vec2 margin = pos2-pos1;
	return line(position, pos1-margin, pos2+margin, 0.03);
}

float scene(vec2 position, float time) {
	float test = 0.0; //TIME;
	vec2 circle_pos = translate(position, vec2(0.5,.5));
	vec2 rect_pos = translate(position, vec2(0.3,0.3));
	rect_pos = rotate(rect_pos, time*2.0);
	float circle = circle(circle_pos, 0.25);
	float rect = rectangle(rect_pos, vec2(.15,.15));
	float scene = interpolate(circle, rect, 0.5*(sin(time)+1.0));
	
	ivec3 connections[4];
	connections[0] = connections_n;
	connections[1] = connections_e;
	connections[2] = connections_s;
	connections[3] = connections_w;
	scene = 1.0;
	bool tracks[6] = {NS, NE, NW, SE, SW, EW};
		
	if (NS) {
		float track = track_segment(position, 0, 2);
		scene = merge(scene, track)
	}
	if (NE) {
		float track = track_segment(position, 0, 1);
		scene = merge(scene, track)
	}
	if (NW) {
		float track = track_segment(position, 0, 3);
		scene = merge(scene, track)
	}
	if (SE) {
		float track = track_segment(position, 2, 1);
		scene = merge(scene, track)
	}
	if (SW) {
		float track = track_segment(position, 2, 3);
		scene = merge(scene, track)
	}
	if (EW) {
		float track = track_segment(position, 1, 3);
		scene = merge(scene, track)
	}
	return scene;
}
void fragment() {
	COLOR = background;
	vec2 position = UV;
	float dist = scene(position, TIME*5.0);
	float dist_change = fwidth(dist)*0.5;
	float t = smoothstep(dist_change, -dist_change, dist);
	COLOR = mix(background, track_base, t);
}"

[resource]
shader = SubResource( 2 )
shader_param/background = Color( 0.286275, 0.133333, 0.133333, 1 )
shader_param/track_base = Color( 1, 1, 1, 1 )
shader_param/track_inner = Color( 0, 0, 0, 1 )
shader_param/NS = true
shader_param/NE = true
shader_param/NW = true
shader_param/SE = true
shader_param/SW = true
shader_param/EW = true
shader_param/matrix = Transform( 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 )
shader_param/connections_n = PoolIntArray( 1, 0, 0 )
shader_param/connections_e = PoolIntArray( 1, 0, 0 )
shader_param/connections_s = PoolIntArray( 1, 0, 0 )
shader_param/connections_w = PoolIntArray( 2, 0, 0 )

[gd_resource type="ShaderMaterial" load_steps=2 format=2]

[sub_resource type="Shader" id=1]
code = "shader_type canvas_item;

uniform vec4 background: hint_color;
uniform vec4 track_base: hint_color;
uniform vec4 track_inner: hint_color;
uniform vec4 switch_color: hint_color;
uniform vec4 grid_color: hint_color;

uniform float grid_width;
uniform float track_width;
uniform float inner_track_width;

uniform bool contours;

uniform mat4 connections;

const float PI = 3.14159265358979323846;

const int LEFT = 1;
const int STRAIGHT = 2;
const int RIGHT = 4;
const int NO_CONNECT = 8;
const int SWITCH_LEFT = 16;
const int SWITCH_STRAIGHT = 32;
const int SWITCH_RIGHT = 64;
const int SWITCH_PRIORITY_LEFT = 128;
const int SWITCH_PRIORITY_STRAIGHT = 256;
const int SWITCH_PRIORITY_RIGHT = 512;


float circle(vec2 position, float radius) {
    return length(position) - radius;
}

float rectangle(vec2 position, vec2 size) {
    vec2 component_distance = abs(position) - size;
    float outside_distance = length(max(component_distance, 0.0));
    float inside_distance = min(max(component_distance.x, component_distance.y), 0.0);
    return outside_distance + inside_distance;
	// return component_distance.x;
}

float pie(vec2 position, vec2 aperture, float radius)
{
    position.x = abs(position.x);
    float l = length(position) - radius;
	float m = length(position - aperture*clamp(dot(position,aperture),0.0,radius) );
    return max(l,m*sign(aperture.y*position.x-aperture.x*position.y));
}

float arc( vec2 p, float aperture, float orientation, float ra, float rb )
{
	vec2 scb = vec2(sin(aperture), cos(aperture));
	vec2 sca = vec2(sin(orientation), cos(orientation));
    p *= mat2(vec2(sca.x,sca.y), vec2(-sca.y,sca.x));
    p.x = abs(p.x);
    float k = (scb.y*p.x>scb.x*p.y) ? dot(p.xy,scb) : length(p);
    return sqrt( max(0.0, dot(p,p) + ra*ra - 2.0*ra*k ) ) - rb;
}

vec2 translate(vec2 position, vec2 offset) {
	return position - offset;
}

float track_arc( vec2 position, vec2 center, float radius, float start_angle, float delta_angle, float width) {
	float aperture = abs(delta_angle*0.5);
	float orientation = (-start_angle - delta_angle*0.5) + PI;
	position = translate(position, center);
	return arc(position, aperture, orientation, radius, width);
}

vec2 rotate(vec2 position, float rotation) {
    float angle = rotation;
    float sine = sin(angle);
	float cosine = cos(angle);
    return vec2(cosine * position.x + sine * position.y, cosine * position.y - sine * position.x);
}

float merge(float shape1, float shape2) {
	return min(shape1, shape2);
}

float intersect(float shape1, float shape2) {
	return max(shape1, shape2);
}

float substract(float shape1, float shape2) {
	return intersect(shape1, -shape2);
}

float interpolate(float shape1, float shape2, float t) {
	return mix(shape1, shape2, t);
}

float segment( vec2 p, vec2 a, vec2 b )
{
    vec2 pa = p-a, ba = b-a;
    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );
    return length( pa - ba*h );
}

float line( vec2 position, vec2 from, vec2 to, float width) {
	return segment(position, from, to) - width;
}

float line_rect(vec2 position, vec2 from, vec2 to, float width) {
	vec2 delta = to-from;
	float angle = atan(delta.y, delta.x);
	vec2 rect_pos = position;
	rect_pos = translate(rect_pos, 0.5*(from+to));
	rect_pos = rotate(rect_pos, angle);
	float rect = rectangle(rect_pos,vec2(length(delta)*0.5, width));
	return rect;
}

float track_connection(vec2 position, int from_slot, int to_slot, int turn_index, float width, bool border) {
	vec2 slot_positions[4] = {vec2(0.5, 0.0), vec2(1.0, 0.5), vec2(0.5, 1.0), vec2(0.0, 0.5)};

	float scene = 10.0;
	
	vec2 from_pos = slot_positions[from_slot];
	vec2 to_pos = slot_positions[to_slot];
	vec2 tangent = to_pos-from_pos;
	vec2 to_pos_opposite = slot_positions[(to_slot+2)%4];
	vec2 aligned = to_pos - to_pos_opposite;
	float this_angle = atan(tangent.y, tangent.x);
	float straight_angle = atan(aligned.y, aligned.x);
	float aligned_angle = this_angle - straight_angle;
	while (aligned_angle > PI) {
		aligned_angle -= 2.0*PI;
	}
	while (aligned_angle < -PI) {
		aligned_angle += 2.0*PI;
	}
	int track_alignment = int(sign(aligned_angle));
	// track_alignment = -1;
	int curve_index = turn_index-track_alignment;
	float radius;
	float start_angle;
	float delta_angle;
	vec2 center;
	start_angle = this_angle - 0.5*PI*float(sign(curve_index));
	delta_angle = float(curve_index)*PI/4.0;
	if (turn_index == 2) {
		vec2 end_pos = from_pos+tangent*0.7;
		float straight = line(position, from_pos+tangent*0.5, end_pos-normalize(tangent)*width*0.5, track_width);
		scene = merge(scene, straight);
		// float endcap = circle(position-from_pos-tangent*0.5, width);
		// scene = merge(scene, endcap);
		vec2 normal = vec2(cos(this_angle+PI*0.5), sin(this_angle+PI*0.5));
		float stopper = line_rect(position, end_pos-normal*track_width*2.0, end_pos+normal*track_width*2.0, track_width);
		scene = merge(scene, stopper);
		return scene;
	}
	else if (abs(curve_index)==2) {
		radius = 0.25*sqrt(2.0);
		center = from_pos + aligned*0.5;
		float connection = track_arc(position, center, radius, start_angle, delta_angle, width);
		scene = merge(scene, connection);
	}
	else if (abs(curve_index)==1) {
		radius = 0.5+sqrt(2.0)*0.25;
		float center_angle = this_angle + 0.5*PI*float(sign(curve_index));
		center = from_pos + tangent*0.5 + vec2(cos(center_angle), sin(center_angle))*radius;
		if (dot(tangent,aligned) > 0.99) {
			center += tangent*0.25*(2.0-sqrt(2.0));
			float straight = line(position, from_pos+tangent*0.5, to_pos-tangent*(0.25*sqrt(2.0)),width);
			scene = merge(scene, straight);
			// float endcap = circle(position-from_pos-tangent*0.5, width);
			// scene = merge(scene, endcap);
		}
		float connection = track_arc(position, center, radius, start_angle, delta_angle, width);
		scene = merge(scene, connection);
	}
	else if (curve_index == 0) {
		float straight = line(position, from_pos+tangent*0.5, to_pos+tangent, width);
		scene = merge(scene, straight);
		// float endcap = circle(position-from_pos-tangent*0.5, width);
		// scene = merge(scene, endcap);
	}
	
	if (border) {
		float inner = scene - inner_track_width;
		float outer = scene - track_width;
		scene = substract(outer, inner);
		float center_substract = line_rect(position, from_pos+tangent*0.5,from_pos, track_width);
		if (abs(tangent.x) < 0.0005 || abs(tangent.y) < 0.0005) {
			center_substract = line_rect(position, from_pos+tangent*(0.5+track_width),from_pos, track_width);
		}
		scene = substract(scene, center_substract);
	}
	else {
		scene = scene - track_width;
	}
	return scene;
	
}

float tracks(vec2 position, float time, bool switch_position) {
	vec2 circle_pos = translate(position, vec2(0.5,.5));
	vec2 rect_pos = translate(position, vec2(0.3,0.3));
	rect_pos = rotate(rect_pos, time*1.0);
	float circle = circle(circle_pos, 0.25);
	float rect = rectangle(rect_pos, vec2(.15,.15));
	
	int turn_flags[3] = {LEFT, STRAIGHT, RIGHT};
	if (switch_position) {
		turn_flags[0] = SWITCH_LEFT;
		turn_flags[1] = SWITCH_STRAIGHT;
		turn_flags[2] = SWITCH_RIGHT;
	}
	// float scene = interpolate(circle, rect, 0.5*(sin(time)+1.0));
	
	float aperture = (cos(time)+1.0)*PI;
	float orientation = (sin(time)+1.0)*PI*0.5;
	vec2 pie_center = vec2(0.5,0.5);
	vec2 pie_pos = translate(position, pie_center);
	orientation = PI/2.0;
	float pie = pie(position, vec2(sin(aperture), cos(aperture)), 0.3);
	// float arc = arc(pie_pos, aperture, orientation, 0.2, 0.01);
	float arc = track_arc(position, pie_center, 0.5, orientation, aperture, 0.01);
	
	// float track = track_connection(position, 2, 3, 3, 0.03);
	
	float scene = 10.0; //merge(scene, pie);
	
	vec4 basis[4] = {vec4(1.0, 0.0, 0.0, 0.0), vec4(0.0, 1.0, 0.0, 0.0), vec4(0.0, 0.0, 1.0, 0.0), vec4(0.0, 0.0, 0.0, 1.0)};
	
	for (int from_slot=0; from_slot<4; from_slot++) {
		for (int to_slot=0; to_slot<3; to_slot++) {
			vec4 from_vec = basis[from_slot];
			vec4 to_vec = basis[to_slot];
			int connection_flags = int(dot(to_vec, connections*from_vec));
			// connection_flags = 0;
			int to_slot2 = to_slot;
			if (from_slot == to_slot) {
				to_slot2 = 3;
			}
			float connection;
			float width = track_width;
			for (int flag=0; flag<3; flag++) {
				int turn = flag-1;
				if ((connection_flags & turn_flags[flag]) != turn_flags[flag]) {
					continue;
				}
				connection = track_connection(position, from_slot, to_slot2, turn, 0.0, switch_position);
				scene = merge(scene, connection);
			}
			if (!switch_position && ((connection_flags & NO_CONNECT) == NO_CONNECT)) {
				connection = track_connection(position, from_slot, to_slot2, 2, 0.0, switch_position);
				scene = merge(scene, connection);
			}
	
		}
	}
	// scene = merge(scene, arc);
	
	// scene = 1.0;
	
	return scene;
}
void fragment() {
	vec4 bg = background;
	vec2 position = UV;
	if (position.x<grid_width*0.5 || position.x>1.0-grid_width*0.5 || position.y<grid_width*0.5 || position.y>1.0-grid_width*0.5) {
		bg = grid_color;
	}
	float base = tracks(position, TIME*1.0, false);
	float turn_outer = tracks(position, TIME*1.0, true);
	float inner = base + track_width - inner_track_width;
	float switch_outer = intersect(turn_outer, inner);
	
	float dist = base;
	float base_change = fwidth(base)*0.5;
	float inner_change = fwidth(inner)*0.5;
	float switch_outer_change = fwidth(switch_outer)*0.5;
	float t = smoothstep(base_change, -base_change, base);
	vec4 bg_mix = mix(bg, track_base, t);
	t = smoothstep(inner_change, -inner_change, inner);
	vec4 track_mix = mix(bg_mix, track_inner, t);
	t = smoothstep(switch_outer_change, -switch_outer_change, switch_outer);
	COLOR = mix(track_mix, switch_color, t);
	
	
	if (contours) {
		dist = base;
		vec3 col = vec3(1.0) - sign(dist)*vec3(0.1,0.4,0.7);
		col *= 1.0 - exp(-2.0*abs(dist));
		col *= 0.8 + 0.2*cos(128.0*abs(dist));
		col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(dist)) );
		COLOR.rgb = col;
	}
}"

[resource]
shader = SubResource( 1 )
shader_param/background = Color( 0.129412, 0.0980392, 0.0980392, 1 )
shader_param/track_base = Color( 1, 1, 1, 1 )
shader_param/track_inner = Color( 0, 0, 0, 1 )
shader_param/switch_color = Color( 0.113725, 0.501961, 0.862745, 1 )
shader_param/grid_color = Color( 0.0509804, 0.0352941, 0.0352941, 1 )
shader_param/grid_width = 0.064
shader_param/track_width = 0.06
shader_param/inner_track_width = 0.03
shader_param/contours = false
shader_param/connections = Transform( 4.032, 35.245, 3.972, 8.927, 3.213, 2.327, 22.052, 1.52, 5.602, 1.569, 2.568, 1.899 )

[gd_resource type="ShaderMaterial" load_steps=2 format=2]

[sub_resource type="Shader" id=1]
code = "shader_type canvas_item;

uniform vec4 background: hint_color;
uniform vec4 track_base: hint_color;
uniform vec4 track_inner: hint_color;
uniform vec4 switch_color: hint_color;
uniform vec4 grid_color: hint_color;
uniform vec4 switch_inner_color: hint_color;
uniform vec4 selected_color: hint_color;
uniform vec4 hover_color: hint_color;


uniform float grid_width;
uniform float track_width;
uniform float inner_track_width;
uniform float stopper_delta;
uniform float stopper_size;
uniform float stopper_width;

uniform bool contours;

uniform mat4 connections;

const float PI = 3.14159265358979323846;

const int LEFT = 1;
const int STRAIGHT = 2;
const int RIGHT = 4;
const int NO_CONNECT = 8;
const int SWITCH_LEFT = 16;
const int SWITCH_STRAIGHT = 32;
const int SWITCH_RIGHT = 64;
const int SWITCH_PRIORITY_LEFT = 128;
const int SWITCH_PRIORITY_STRAIGHT = 256;
const int SWITCH_PRIORITY_RIGHT = 512;
const int SELECTED_LEFT = 1024;
const int SELECTED_STRAIGHT = 2048;
const int SELECTED_RIGHT = 4096;
const int HOVER_LEFT = 8192;
const int HOVER_STRAIGHT = 16384;
const int HOVER_RIGHT = 32768;

const int TRACK_LINE = 0;
const int TRACK_FULL = 1;
const int TRACK_BORDER = 2;
const int TRACK_ARROW = 3;

const int TURN_BASE = 0;
const int TURN_SWITCH_ALL = 1;
const int TURN_SWITCH_PRIORITY = 2;
const int TURN_SELECTED = 3;
const int TURN_HOVER = 4;


float circle(vec2 position, float radius) {
    return length(position) - radius;
}

float rectangle(vec2 position, vec2 size) {
    vec2 component_distance = abs(position) - size;
    float outside_distance = length(max(component_distance, 0.0));
    float inside_distance = min(max(component_distance.x, component_distance.y), 0.0);
    return outside_distance + inside_distance;
	// return component_distance.x;
}

float pie(vec2 position, vec2 aperture, float radius)
{
    position.x = abs(position.x);
    float l = length(position) - radius;
	float m = length(position - aperture*clamp(dot(position,aperture),0.0,radius) );
    return max(l,m*sign(aperture.y*position.x-aperture.x*position.y));
}

float arc( vec2 p, float aperture, float orientation, float ra, float rb )
{
	vec2 scb = vec2(sin(aperture), cos(aperture));
	vec2 sca = vec2(sin(orientation), cos(orientation));
    p *= mat2(vec2(sca.x,sca.y), vec2(-sca.y,sca.x));
    p.x = abs(p.x);
    float k = (scb.y*p.x>scb.x*p.y) ? dot(p.xy,scb) : length(p);
    return sqrt( max(0.0, dot(p,p) + ra*ra - 2.0*ra*k ) ) - rb;
}

vec2 translate(vec2 position, vec2 offset) {
	return position - offset;
}

float track_arc( vec2 position, vec2 center, float radius, float start_angle, float delta_angle, float width) {
	float aperture = abs(delta_angle*0.5);
	float orientation = (-start_angle - delta_angle*0.5) + PI;
	position = translate(position, center);
	return arc(position, aperture, orientation, radius, width);
}

vec2 rotate(vec2 position, float rotation) {
    float angle = rotation;
    float sine = sin(angle);
	float cosine = cos(angle);
    return vec2(cosine * position.x + sine * position.y, cosine * position.y - sine * position.x);
}

float merge(float shape1, float shape2) {
	return min(shape1, shape2);
}

float intersect(float shape1, float shape2) {
	return max(shape1, shape2);
}

float substract(float shape1, float shape2) {
	return intersect(shape1, -shape2);
}

float interpolate(float shape1, float shape2, float t) {
	return mix(shape1, shape2, t);
}

float segment( vec2 p, vec2 a, vec2 b )
{
    vec2 pa = p-a, ba = b-a;
    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );
    return length( pa - ba*h );
}

float line( vec2 position, vec2 from, vec2 to, float width) {
	return segment(position, from, to) - width;
}

float line_rect(vec2 position, vec2 from, vec2 to, float width) {
	vec2 delta = to-from;
	float angle = atan(delta.y, delta.x);
	vec2 rect_pos = position;
	rect_pos = translate(rect_pos, 0.5*(from+to));
	rect_pos = rotate(rect_pos, angle);
	float rect = rectangle(rect_pos,vec2(length(delta)*0.5, width));
	return rect;
}

float track_connection(vec2 position, int from_slot, int to_slot, int turn_index, int track_type) {
	vec2 slot_positions[4] = {vec2(0.5, 0.0), vec2(1.0, 0.5), vec2(0.5, 1.0), vec2(0.0, 0.5)};

	float scene = 10.0;
	float width = track_width;
	if (track_type==TRACK_LINE || track_type==TRACK_BORDER) {
		width = 0.0;
	}
	
	vec2 from_pos = slot_positions[from_slot];
	vec2 to_pos = slot_positions[to_slot];
	vec2 tangent = to_pos-from_pos;
	vec2 to_pos_opposite = slot_positions[(to_slot+2)%4];
	vec2 aligned = to_pos - to_pos_opposite;
	float this_angle = atan(tangent.y, tangent.x);
	float straight_angle = atan(aligned.y, aligned.x);
	float aligned_angle = this_angle - straight_angle;
	while (aligned_angle > PI) {
		aligned_angle -= 2.0*PI;
	}
	while (aligned_angle < -PI) {
		aligned_angle += 2.0*PI;
	}
	int track_alignment = int(sign(aligned_angle));
	// track_alignment = -1;
	int curve_index = turn_index-track_alignment;
	float radius;
	float start_angle;
	float delta_angle;
	vec2 center;
	start_angle = this_angle - 0.5*PI*float(sign(curve_index));
	delta_angle = float(curve_index)*PI/4.0;
	if (turn_index == 2) {
		vec2 end_pos = from_pos+tangent*stopper_delta;
		vec2 straight_end = end_pos+ normalize(tangent)*stopper_width;
		straight_end = end_pos+ normalize(tangent)*stopper_width*0.5;
		float straight = line_rect(position, from_pos+tangent*0.5, straight_end, width);
		scene = merge(scene, straight);
		float round_straight = line(position, from_pos+tangent*0.5, straight_end - normalize(tangent)*track_width, width);
		scene = merge(scene, round_straight);
		// float endcap = circle(position-from_pos-tangent*0.5, width);
		// scene = merge(scene, endcap);
		vec2 stopper_pos = end_pos;
		vec2 normal = vec2(cos(this_angle+PI*0.5), sin(this_angle+PI*0.5));
		float stopper = line(position, stopper_pos-normal*track_width*stopper_size, stopper_pos+normal*track_width*stopper_size, stopper_width);
		scene = merge(scene, stopper);
		return scene;
	}
	else if (abs(curve_index)==2) {
		radius = 0.25*sqrt(2.0);
		center = from_pos + aligned*0.5;
		float connection = track_arc(position, center, radius, start_angle, delta_angle, width);
		scene = merge(scene, connection);
	}
	else if (abs(curve_index)==1) {
		radius = 0.5+sqrt(2.0)*0.25;
		float center_angle = this_angle + 0.5*PI*float(sign(curve_index));
		center = from_pos + tangent*0.5 + vec2(cos(center_angle), sin(center_angle))*radius;
		if (dot(tangent,aligned) > 0.99) {
			center += tangent*0.25*(2.0-sqrt(2.0));
			float straight = line(position, from_pos+tangent*0.5, to_pos-tangent*(0.25*sqrt(2.0)),width);
			scene = merge(scene, straight);
			// float endcap = circle(position-from_pos-tangent*0.5, width);
			// scene = merge(scene, endcap);
		}
		float connection = track_arc(position, center, radius, start_angle, delta_angle, width);
		scene = merge(scene, connection);
	}
	else if (curve_index == 0) {
		float straight = line(position, from_pos+tangent*0.5, to_pos+tangent, width);
		scene = merge(scene, straight);
		// float endcap = circle(position-from_pos-tangent*0.5, width);
		// scene = merge(scene, endcap);
	}
	
	if (track_type == TRACK_BORDER) {
		float inner = scene - inner_track_width;
		float outer = scene - track_width;
		scene = substract(outer, inner);
		float center_substract = line_rect(position, from_pos+tangent*0.5,from_pos, track_width);
		if (abs(tangent.x) < 0.0005 || abs(tangent.y) < 0.0005) {
			center_substract = line_rect(position, from_pos+tangent*(0.5+track_width),from_pos, track_width*1.05);
		}
		scene = substract(scene, center_substract);
	}
	return scene;
	
}

float tracks(vec2 position, int turn_type, int track_type) {
	
	int turn_flags[3] = {LEFT, STRAIGHT, RIGHT};
	if (turn_type == TURN_SWITCH_PRIORITY) {
		turn_flags[0] = SWITCH_PRIORITY_LEFT;
		turn_flags[1] = SWITCH_PRIORITY_STRAIGHT;
		turn_flags[2] = SWITCH_PRIORITY_RIGHT;
		}
	if (turn_type == TURN_SWITCH_ALL) {
			turn_flags[0] = SWITCH_LEFT;
			turn_flags[1] = SWITCH_STRAIGHT;
			turn_flags[2] = SWITCH_RIGHT;
	}
	if (turn_type == TURN_SELECTED) {
			turn_flags[0] = SELECTED_LEFT;
			turn_flags[1] = SELECTED_STRAIGHT;
			turn_flags[2] = SELECTED_RIGHT;
	}
	if (turn_type == TURN_HOVER) {
			turn_flags[0] = HOVER_LEFT;
			turn_flags[1] = HOVER_STRAIGHT;
			turn_flags[2] = HOVER_RIGHT;
	}
	
	float scene = 10.0;
	
	vec4 basis[4] = {vec4(1.0, 0.0, 0.0, 0.0), vec4(0.0, 1.0, 0.0, 0.0), vec4(0.0, 0.0, 1.0, 0.0), vec4(0.0, 0.0, 0.0, 1.0)};
	
	for (int from_slot=0; from_slot<4; from_slot++) {
		vec4 from_vec = basis[from_slot];
		for (int to_slot=0; to_slot<3; to_slot++) {
			vec4 to_vec = basis[to_slot];
			int connection_flags = int(dot(to_vec, connections*from_vec));
			int to_slot2 = to_slot;
			if (from_slot == to_slot) {
				to_slot2 = 3;
			}
			float connection;
			float width = track_width;
			for (int flag=0; flag<3; flag++) {
				int turn = flag-1;
				if ((connection_flags & turn_flags[flag]) != turn_flags[flag]) {
					continue;
				}
				connection = track_connection(position, from_slot, to_slot2, turn, track_type);
				scene = merge(scene, connection);
			}
			if (turn_type==TURN_BASE && ((connection_flags & NO_CONNECT) == NO_CONNECT)) {
				connection = track_connection(position, from_slot, to_slot2, 2, track_type);
				scene = merge(scene, connection);
			}
	
		}
	}
	
	return scene;
}
void fragment() {
	vec4 bg = background;
	vec2 position = UV;
	float border_dist = min(position.x, min(position.y, min(1.0-position.x, 1.0-position.y)));
	if (border_dist<grid_width*0.5) {
		bg = grid_color;
	}
	float base = tracks(position, TURN_BASE, TRACK_FULL);
	float turn_outer = tracks(position, TURN_SWITCH_ALL, TRACK_BORDER);
	float inner = base + track_width - inner_track_width;
	float switch_outer = intersect(turn_outer, inner);
	float switch_base = tracks(position, TURN_SWITCH_PRIORITY, TRACK_LINE);
	float selected = tracks(position, TURN_SELECTED, TRACK_FULL);
	float selected_inner = intersect(inner, selected);
	float hover = tracks(position, TURN_HOVER, TRACK_FULL);
	float hover_inner = intersect(inner, hover);
	
	float arrow_cap = clamp(20.0*(border_dist-0.02), -1.0, 1.0);
	float arrow_modulate = (border_dist<0.4) ? arrow_cap : -1.0;
	arrow_modulate = arrow_cap  * clamp(20.0*(-border_dist+0.25), -1.0, 1.0);
	// arrow_modulate = sqrt(max(1.0-(1.0-arrow_modulate)*(1.0-arrow_modulate),0.0));
	float switch_arrows = switch_base - (arrow_modulate)*inner_track_width*0.4;
	
	float dist = base;
	float base_change = fwidth(base)*0.5;
	float inner_change = fwidth(inner)*0.5;
	float selected_inner_change = fwidth(selected_inner)*0.5;
	float hover_inner_change = fwidth(hover_inner)*0.5;
	float switch_outer_change = fwidth(switch_outer)*0.5;
	float switch_arrows_change = fwidth(switch_arrows)*0.5;
	float t = smoothstep(base_change, -base_change, base);
	vec4 bg_mix = mix(bg, track_base, t);
	t = smoothstep(inner_change, -inner_change, inner);
	vec4 track_mix = mix(bg_mix, track_inner, t);
	t = smoothstep(selected_inner_change, -selected_inner_change, selected_inner);
	vec4 selected_mix = mix(track_mix, selected_color, t);
	t = smoothstep(hover_inner_change, -hover_inner_change, hover_inner);
	vec4 hover_mix = mix(selected_mix, hover_color, t);
	t = smoothstep(switch_outer_change, -switch_outer_change, switch_outer);
	vec4 switch_mix = mix(hover_mix, switch_color, t);
	t = smoothstep(switch_arrows_change, -switch_arrows_change, switch_arrows);
	COLOR = mix(switch_mix, switch_inner_color, t);
	
	if (contours) {
		dist = base;
		vec3 col = vec3(1.0) - sign(dist)*vec3(0.1,0.4,0.7);
		col *= 1.0 - exp(-2.0*abs(dist));
		col *= 0.8 + 0.2*cos(128.0*abs(dist));
		col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(dist)) );
		COLOR.rgb = col;
	}
}"

[resource]
shader = SubResource( 1 )
shader_param/background = Color( 0.105882, 0.109804, 0.121569, 1 )
shader_param/track_base = Color( 1, 1, 1, 1 )
shader_param/track_inner = Color( 0, 0, 0, 1 )
shader_param/switch_color = Color( 0.219608, 0.517647, 0.803922, 1 )
shader_param/grid_color = Color( 0.0352941, 0.0352941, 0.0392157, 1 )
shader_param/switch_inner_color = Color( 0.509804, 0.87451, 1, 1 )
shader_param/selected_color = Color( 0.647059, 0.215686, 0.168627, 1 )
shader_param/hover_color = Color( 0.133333, 0.615686, 0.647059, 1 )
shader_param/grid_width = 0.097
shader_param/track_width = 0.126
shader_param/inner_track_width = 0.062
shader_param/stopper_delta = 0.677
shader_param/stopper_size = 0.563
shader_param/stopper_width = 0.11
shader_param/contours = false
shader_param/connections = Transform( 0, 42.708, 3.972, 2056.09, 2271.59, 2.327, 2054.03, 129.175, 0, 1.569, 2.568, 1.899 )
